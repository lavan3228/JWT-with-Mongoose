"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sequelize_1 = require("sequelize");
const string_1 = require("../../common/utils/string");
const models_1 = require("../models");
const ModelNotInitializedError_1 = require("../../common/errors/ModelNotInitializedError");
const object_1 = require("../../common/utils/object");
exports._SeqModel = sequelize_1.Model;
/**
 * Indicates which static methods of Model has to be proxied,
 * to prepare include option to automatically resolve alias;
 * The index represents the index of the options of the
 * corresponding method parameter
 */
exports.INFER_ALIAS_MAP = {
    bulkBuild: 1,
    build: 1,
    create: 1,
    aggregate: 2,
    all: 0,
    find: 0,
    findAll: 0,
    findAndCount: 0,
    findAndCountAll: 0,
    findById: 1,
    findByPrimary: 1,
    findCreateFind: 0,
    findOne: 0,
    findOrBuild: 0,
    findOrCreate: 0,
    findOrInitialize: 0,
    reload: 0,
};
const staticModelFunctionProperties = object_1.getAllPropertyNames(sequelize_1.Model)
    .filter(key => !isForbiddenMember(key) &&
    isFunctionMember(key, sequelize_1.Model) &&
    !isPrivateMember(key));
class ModelImpl extends exports._SeqModel {
    constructor(values, options) {
        super(values, models_1.inferAlias(options, new.target));
    }
    static init(...args) {
        this.isInitialized = true;
        return super.init(...args);
    }
    static addThrowNotInitializedProxy() {
        staticModelFunctionProperties
            .forEach(key => {
            const superFn = this[key];
            this[key] = function (...args) {
                if (!this.isInitialized) {
                    throw new ModelNotInitializedError_1.ModelNotInitializedError(this, { accessedPropertyKey: key });
                }
                return superFn.call(this, ...args);
            };
        });
    }
    static addInferAliasOverrides() {
        Object
            .keys(exports.INFER_ALIAS_MAP)
            .forEach(key => {
            const optionIndex = exports.INFER_ALIAS_MAP[key];
            const superFn = this[key];
            this[key] = function (...args) {
                args[optionIndex] = models_1.inferAlias(args[optionIndex], this);
                return superFn.call(this, ...args);
            };
        });
    }
    /**
     * Adds relation between specified instances and source instance
     */
    $add(propertyKey, instances, options) {
        return this['add' + string_1.capitalize(propertyKey)](instances, options);
    }
    ;
    /**
     * Sets relation between specified instances and source instance
     * (replaces old relations)
     */
    $set(propertyKey, instances, options) {
        return this['set' + string_1.capitalize(propertyKey)](instances, options);
    }
    ;
    /**
     * Returns related instance (specified by propertyKey) of source instance
     */
    $get(propertyKey, options) {
        return this['get' + string_1.capitalize(propertyKey)](options);
    }
    ;
    /**
     * Counts related instances (specified by propertyKey) of source instance
     */
    $count(propertyKey, options) {
        return this['count' + string_1.capitalize(propertyKey)](options);
    }
    ;
    /**
     * Creates instances and relate them to source instance
     */
    $create(propertyKey, values, options) {
        return this['create' + string_1.capitalize(propertyKey)](values, options);
    }
    ;
    /**
     * Checks if specified instances is related to source instance
     */
    $has(propertyKey, instances, options) {
        return this['has' + string_1.capitalize(propertyKey)](instances, options);
    }
    ;
    /**
     * Removes specified instances from source instance
     */
    $remove(propertyKey, instances, options) {
        return this['remove' + string_1.capitalize(propertyKey)](instances, options);
    }
    ;
    /**
     * Overridden due to infer alias from options is required
     *
     * SEE DETAILS FOR ACTUAL FUNCTIONALITY ON DECLARATION FILE
     */
    reload(options) {
        return exports._SeqModel.prototype.reload.call(this, models_1.inferAlias(options, this));
    }
    ;
}
ModelImpl.isInitialized = false;
exports.ModelImpl = ModelImpl;
function isFunctionMember(propertyKey, target) {
    return typeof target[propertyKey] === 'function';
}
function isForbiddenMember(propertyKey) {
    const FORBIDDEN_KEYS = ['name', 'constructor', 'length', 'prototype', 'caller', 'arguments', 'apply',
        'QueryInterface', 'QueryGenerator', 'init', 'replaceHookAliases', 'refreshAttributes'];
    return FORBIDDEN_KEYS.indexOf(propertyKey) !== -1;
}
function isPrivateMember(propertyKey) {
    return (propertyKey.charAt(0) === '_');
}
ModelImpl.addThrowNotInitializedProxy();
ModelImpl.addInferAliasOverrides();
//# sourceMappingURL=ModelImpl.js.map