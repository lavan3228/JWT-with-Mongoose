"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const glob = require("glob");
const path = require("path");
const Model_1 = require("./models/Model");
const object_1 = require("../common/utils/object");
const association_1 = require("../associations/association");
const array_1 = require("../common/utils/array");
const data_type_1 = require("../sequelize/data-type");
const MODEL_NAME_KEY = 'sequelize:modelName';
const ATTRIBUTES_KEY = 'sequelize:attributes';
const OPTIONS_KEY = 'sequelize:options';
exports.DEFAULT_DEFINE_OPTIONS = {
    timestamps: false
};
/**
 * Sets model name from class by storing this
 * information through reflect metadata
 */
function setModelName(target, modelName) {
    Reflect.defineMetadata(MODEL_NAME_KEY, modelName, target);
}
exports.setModelName = setModelName;
/**
 * Returns model name from class by restoring this
 * information from reflect metadata
 */
function getModelName(target) {
    return Reflect.getMetadata(MODEL_NAME_KEY, target);
}
exports.getModelName = getModelName;
/**
 * Returns model attributes from class by restoring this
 * information from reflect metadata
 */
function getAttributes(target) {
    const attributes = Reflect.getMetadata(ATTRIBUTES_KEY, target);
    if (attributes) {
        return Object
            .keys(attributes)
            .reduce((copy, key) => {
            copy[key] = Object.assign({}, attributes[key]);
            return copy;
        }, {});
    }
}
exports.getAttributes = getAttributes;
/**
 * Sets attributes
 */
function setAttributes(target, attributes) {
    Reflect.defineMetadata(ATTRIBUTES_KEY, Object.assign({}, attributes), target);
}
exports.setAttributes = setAttributes;
/**
 * Adds model attribute by specified property name and
 * sequelize attribute options and stores this information
 * through reflect metadata
 */
function addAttribute(target, name, options) {
    let attributes = getAttributes(target);
    if (!attributes) {
        attributes = {};
    }
    attributes[name] = Object.assign({}, options);
    setAttributes(target, attributes);
}
exports.addAttribute = addAttribute;
/**
 * Adds attribute options for specific attribute
 */
function addAttributeOptions(target, propertyName, options) {
    const attributes = getAttributes(target);
    if (!attributes || !attributes[propertyName]) {
        throw new Error(`@Column annotation is missing for "${propertyName}" of class "${target.constructor.name}"` +
            ` or annotation order is wrong.`);
    }
    attributes[propertyName] = object_1.deepAssign(attributes[propertyName], options);
    setAttributes(target, attributes);
}
exports.addAttributeOptions = addAttributeOptions;
/**
 * Returns sequelize define options from class prototype
 * by restoring this information from reflect metadata
 */
function getOptions(target) {
    const options = Reflect.getMetadata(OPTIONS_KEY, target);
    if (options) {
        return Object.assign({}, options);
    }
}
exports.getOptions = getOptions;
/**
 * Sets seuqlize define options to class prototype
 */
function setOptions(target, options) {
    Reflect.defineMetadata(OPTIONS_KEY, Object.assign({}, options), target);
}
exports.setOptions = setOptions;
/**
 * Adds options be assigning new options to old one
 */
function addOptions(target, options) {
    let _options = getOptions(target);
    if (!_options) {
        _options = {};
    }
    setOptions(target, Object.assign({}, _options, options, { validate: Object.assign({}, (_options.validate || {}), (options.validate || {})) }));
}
exports.addOptions = addOptions;
/**
 * Maps design types to sequelize data types;
 * @throws if design type cannot be automatically mapped to
 * a sequelize data type
 */
function getSequelizeTypeByDesignType(target, propertyName) {
    const type = Reflect.getMetadata('design:type', target, propertyName);
    const dataType = data_type_1.inferDataType(type);
    if (dataType) {
        return dataType;
    }
    throw new Error(`Specified type of property '${propertyName}'
            cannot be automatically resolved to a sequelize data type. Please
            define the data type manually`);
}
exports.getSequelizeTypeByDesignType = getSequelizeTypeByDesignType;
/**
 * Determines models from value
 */
function getModels(arg) {
    if (arg && typeof arg[0] === 'string') {
        return arg.reduce((models, dir) => {
            if (!glob.hasMagic(dir))
                dir = path.join(dir, '/*');
            const _models = glob
                .sync(dir)
                .filter(isImportable)
                .map(getFullfilepathWithoutExtension)
                .filter(array_1.uniqueFilter)
                .map(fullPath => {
                const module = require(fullPath);
                const fileName = getFilenameWithoutExtension(fullPath);
                if (!module[fileName] && !module.default) {
                    throw new Error(`No default export defined for file "${fileName}" or ` +
                        `export does not satisfy filename.`);
                }
                return module[fileName] || module.default;
            });
            models.push(..._models);
            return models;
        }, []);
    }
    return arg;
}
exports.getModels = getModels;
/**
 * Resolves all model getters of specified options object
 * recursively.
 * So that {model: () => Person} will be converted to
 * {model: Person}
 */
function resolveModelGetter(options) {
    const maybeModelGetter = value => typeof value === 'function' && value.length === 0;
    const isModel = value => value && value.prototype && value.prototype instanceof Model_1.Model;
    const isOptionObject = value => value && typeof value === 'object';
    Object
        .keys(options)
        .forEach(key => {
        const value = options[key];
        if (maybeModelGetter(value)) {
            const maybeModel = value();
            if (isModel(maybeModel)) {
                options[key] = maybeModel;
            }
        }
        else if (isOptionObject(value)) {
            resolveModelGetter(value);
        }
    });
}
exports.resolveModelGetter = resolveModelGetter;
/**
 * Pre conform includes, so that "as" value can be inferred from source
 */
function inferAlias(options, source) {
    options = Object.assign({}, options);
    if (!options.include) {
        return options;
    }
    // if include is not an array, wrap in an array
    if (!Array.isArray(options.include)) {
        options.include = [options.include];
    }
    else if (!options.include.length) {
        delete options.include;
        return options;
    }
    options.include = options.include.map((include) => inferAliasForInclude(include, source));
    return options;
}
exports.inferAlias = inferAlias;
/**
 * Pre conform include, so that alias ("as") value can be inferred from source class
 */
function inferAliasForInclude(include, source) {
    const hasModelOptionWithoutAsOption = !!(include.model && !include.as);
    const hasIncludeOptions = !!include.include;
    const isConstructorFn = include instanceof Function;
    if (isConstructorFn || hasModelOptionWithoutAsOption) {
        if (isConstructorFn) {
            include = { model: include };
        }
        const targetPrototype = source.prototype || source;
        const relatedClass = include.model;
        const associations = association_1.getAssociationsByRelation(targetPrototype, relatedClass);
        if (associations.length > 0) {
            if (associations.length > 1) {
                throw new Error(`Alias cannot be inferred: "${source.name}" has multiple ` +
                    `relations with "${include.model.name}"`);
            }
            include.as = associations[0].getSequelizeOptions().as;
        }
    }
    if (!isConstructorFn && hasIncludeOptions) {
        include = inferAlias(include, include.model);
    }
    return include;
}
/**
 * Checks if specified filename is importable or not;
 * Which means that, it needs to have a specific file extension
 */
function isImportable(file) {
    const filePart = file.slice(-3);
    return filePart === '.js' || (filePart === '.ts' && file.slice(-5) !== '.d.ts');
}
/**
 * Removes extension of specified filename and returns this value
 */
function getFilenameWithoutExtension(file) {
    return path.parse(file).name;
}
/**
 * Return the value of the full path with filename, without extension
 */
function getFullfilepathWithoutExtension(file) {
    const parsedFile = path.parse(file);
    return path.join(parsedFile.dir, parsedFile.name);
}
//# sourceMappingURL=models.js.map